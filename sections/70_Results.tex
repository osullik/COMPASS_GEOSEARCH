\section{Analysis and Results}
\label{section:results}

\nrscomment{signpost}

\subsection{Algorithm Analysis}

Our \textbf{locationObjectSearch} implementation searches each quadrant of the candidate location for matching objects that were specified in the query, resulting in a time complexity of $\mathcal{O}(Q + O)$ for $Q$ query points and $O$ objects per location. 
Since the number of query points is typically much smaller than the number of objects per location, we expect to see $\mathcal{O}(O)$ time complexity in most scenarios.

Our \textbf{objectObjectSearch} implementation traverses a matrix of size $\# Objs \times \# Objs$ from North and West, slicing the matrix smaller and smaller as it traverses. 
Since no part of the matrix is looked at more than once, this results in a time complexity of $\mathcal{O}(Q + O^2)$ for $Q$ query points and $O$ objects per location. 
This reduces to $\mathcal{O}(O^2)$ when $Q \ll O$. %Since the number of query points is typically much smaller than the number of objects per location, we expect to see $\mathcal{O}(O^2)$ time complexity in most scenarios.

Our \textbf{cardinalityInvariantObjectObjectSearch} implementation performs \textbf{objectObjectSearch} at most $3Q$ times in the worst case (when every query alignment to each of 3 reference points is necessary), resulting in a time complexity of $\mathcal{O}(Q^2 + Q\times O^2)$ for $Q$ query points and $O$ objects per location, which reduces to $\mathcal{O}(O^2)$ when $Q \ll O$. 


\subsection{Experimental Results}
\nrscomment{add here}
We demonstrate the performance of ........... by comparing execution times of ......... 

\subsubsection{Precision and Recall Performance.} Table \ref{Table:PerformanceResults}
\nrscomment{Discuss table}

\subsubsection{Query Time.}
The query response time for Location-Object search and Object-Object search almost negligibly with increased query terms (Figure \ref{figure:query-time}).
Cardinality Invariant Object-Object search grows logarithmically with number of query terms, which is significantly better than the theoretical complexity, which indicates the search time should scale with $\mathcal{O}(Q^2)$ in the worst case query configuration.
The empirical results show significantly better scalability than the theoretical worst-case because the number of rotations needed to ensure invariance with respect to cardinal directionality is less than $Q$ in practice. 
The worst case is when query points are arranged in a circle, and every point must be aligned to the \textbf{N}, \textbf{W}, and \textbf{NW} reference points, resulting in $3Q$ runs of the regular Object-Object search.
In practice, a pictorial query will typically contain points that are well-dispersed over the query canvas.
In those cases, aligning many of the points in the "middle" of the query space to a given reference point will result in the same Concept Map representation as aligning an outer point to it, and so that Concept Map only needs to be checked against the database once.


\subsubsection{Hardware specifications.} 
All experimental results were obtained using .................

\small{
\begin{table}[h]
    \begin{center}
        \begin{tabular}{ |c|c|c| } 
            \hline
            Search Method & Precision & Recall\\
            \hline
            Location-Centric & $0.234$ & $0.114$ \\ 
            Object-Object & $0.580$ & $0.377$ \\  
            \textbf{Cardinality Invariant Object Object} & \textbf{0.860} & \textbf{0.611} \\ 
            \hline     
        \end{tabular}
        \caption{.....} 
        \label{Table:PerformanceResults}
    \end{center}
\end{table}
}

\begin{figure}[h]
    \centering
        \includesvg[width=0.5\textwidth]{figures/compassQuerySizeTime.svg}
    \caption{\textbf{Empirical Scalability of \emph{COMPASS}'s 3 search methods as number of query terms (constraints) increases. Cardinality Invariant Object-Object search is the only method to show increased response times as query terms grows.}}\label{figure:query-time} 
\end{figure}