\section{Methods}
\label{section:methods}

\begin{algorithm}[H]
    \caption{Location-Object Search}\label{alg:locSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{Q.Loc} Midpoint of query canvas, representing position of Location sought}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{objectLocationSearch}{$Q$, $D$, $Q.Loc$, $D.Loc$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$D.Dict \leftarrow$ makeLocationCentricStructure($D$,$D.Loc$)}
            \State{$Q.Dict \leftarrow$ makeLocationCentricStructure($Q$,$Q.Loc$)}
            \State{$matches \leftarrow$ 0}
            \For{Each $quadrant$ in [$NW$, $NE$, $SW$, $SE$]}
                \For{Each point $P$ in $Q.Dict[quadrant]$}
                    \If{$D.Dict[quadrant]$ contains $P$}
                        \State{$matches \leftarrow matches$ + 1} 
                        \State{Pop $P$ from $D.Dict[quadrant]$} %\Comment So multiples of same objects in query are counted
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} $matches$} \Comment Used to rank against other candidate locs
        \EndProcedure
        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{MakeLocationCentricStructure}{$D$, $D.Loc$}
            \State{$Dict \leftarrow $\{ $NW$: [ ], $NE$:[ ], $SW$: [ ], $SE$: [ ] \}}
            \For{$Obj$ in $D$}%\Comment{R is a row describing a single object}
                \If{$Obj.y$ < $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{}
                        \State{Add $Obj.Name$ to $Dict.SW$}
                \ElsIf{$Obj.y$ < $D.Loc.y$ and $Obj.x$ >= $D.Loc.x$}
                        \State{Add $Obj.Name$ to $Dict.SE$}
                    %\EndIf
                \ElsIf{$Obj.y$ >= $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{$R.x$ <= $Loc.x$} 
                        \State{Add $Obj.Name$ to $Dict.NW$}
                \Else
                        \State{Add $Obj.Name$ to $Dict.NE$}
                    %\EndIf
                \EndIf 
            \EndFor
            \State{\textbf{return} $Dict$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\nrscomment{this needs to be written based on how it's implemented.}

\nrscomment{Generalize makeLocationCentricStructure to use it for query and data, then do set intersections to get num matches?}

\nrscomment{Return ranked set of locations as output}


\subsection{Object-Location Search}
\textbf{Object-location} relations are encoded as a per-location index that subdivides the search space into four quadrants - NorthWest, NorthEast, SouthWest, and SouthEast, splitting on the location coordinates.
It assumes that the user sees the 'center' of the location as their reference point, and assumes that they know where North is when querying. 
To conduct a query, a user inserts query terms around the 'center' of a location on the query canvas. 
Algorithm~\ref{alg:locSearch} describes searching the object-location structure with a simple iteration through the candidate locations, searching each one's NW/NE/SW/SE quadrants for the relevant query objects.
A true positive match occurs when the number of discovered objects in a location matches the number of query objects.
For example, if the user queries for two objects in the southwest and one in the northeast, true positive matches will be all locations that feature those three objects in that configuration. 
There is also the ability to return partial matches, ranked by how close they are to an exact match.


\begin{algorithm}[h]
    \caption{Concept Mapping}\label{alg:geoToGrid}
    \begin{algorithmic}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{createConceptMap}{$D$}
            \State{xList, yList $\leftarrow$ []} 
            %\State{LatList = []} \Comment{A list}
            \State{$M$ $\leftarrow$ [[][]]} \Comment{A matrix of 0s}
            %\State{Sort rows from North to South}
            \For{$Obj$ in $D$} \Comment{Where $D$ sorted (desc) on y coord}     
                \State{Add $Obj$ to $yList$} %\Comment{$R.ID$ is the obj unique ID}
            \EndFor
            %\State{Sort rows from West to East}         
            \For{$Obj$ in $D$}  \Comment{Where $D$ sorted (desc) on x coord}  
                \State{Add $Obj$ to $xList$}
            \EndFor          
            \For{$Obj$ in $xlist$}          
                \State{$i \leftarrow$ index of $Obj$ in $xList$}
                \State{$j \leftarrow$ index of $Obj$ in $yList$}               
                \State{$M$[$i$][$j$] $\leftarrow$ $Obj.Name$} %\Comment{Name of object with $ID$}
            \EndFor        
            \State{\textbf{return} $xList$, $yList$}
        \EndProcedure

        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{xList} A list of terms sorted by x-coordinate}}\Comment{Same number of terms as $yList$}
        \State{\textit{\textbf{yList} A list of terms sorted by y-coordinate}}\Comment{Same number of terms as $xList$}
        \State{- - - - -}
        \Procedure{Order Search Terms}{$xList$, $yList$}
            \State{$Traversed$ $\leftarrow$ []}
            \State{$dir$ = 'x'}
            \While{len($Traversed$) < len($xList$)} 
                \If{$xList$ not empty and $dir$ == 'x'}
                    \State{$term$ = pop($xList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'y'}
                    \EndIf
                \EndIf
                \If{$yList$ not empty and $dir$ == 'y'}
                    \State{$term$ = pop($yList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'x'}
                    \EndIf
                \EndIf
            \EndWhile
            \State{\textbf{return} $Traversed$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Object-Object Search}
\textbf{Object-object} search allows a user to search locations for spatial configurations of objects. 
It assumes that the user knows where north is, and queries are entered pictorially through a query canvas. 
Both the locations and the queries are encoded as objects in sparse $NxN$ matrices, where $N$ is the number of objects at a location (or terms in a query). 
Using algorithm~\ref{alg:geoToGrid}, we assign each object in a given location to a position $(i,j)$ in the matrix where $i$ is its order of appearance from north to south and $j$ is the same object's order of appearance from west to east.
The matrix, which we refer to as a \textit{concept map} abstracts away the complexity of tracking distance and the position of each object to all other objects, while preserving the highly discriminative, and reliable relative spatial positions of objects. 
The intuition of the search is derived from two very simple ideas. First, at any point in time, any point in the location more north than the northern most point or west than the western most point of the query can't be part of a match.
Second, the first idea is recursive.
Searching uses the recursive grid search (Algorithm~\ref{alg:gridSearch}) to identify which locations have objects matching the configuration specified in the pictorial query, and returning the relevant set of results. 
The pictorial query is first converted into a concept map matrix using the same process as a location, outlined in figure~\ref{figure:ConceptMap}.
Next, the search terms in the query matrix are ordered into a queue with the northernmost enqueued first, followed by the westernmost, then the second northernmost, and so on until all search terms are in the queue.
Finally, the grid search is employed to recursively prune the search space and quickly eliminate candidate locations that do not match the query configuration.

\begin{algorithm}[h!]
    \caption{Object-Object Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{objectObjectSearch}{$Q$, $D$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \State{$Q.M$ $\leftarrow$ createConceptMap($Q$)}
            \State{$Q.L$ $\leftarrow$ orderSearchTerms($M$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M$,$Q.L$)}
        \EndProcedure
        
        \State{--------------------------------------------------------------------------------------------------------} 
        \State{\textit{\textbf{D.M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{Q.L} A NW to SE ordered list of query objects}}
        \State{\textit{\textbf{Dir} The alternating cardinal direction to prune from, 'N' (default) or 'W'}}
        \State{- - - - -}
        \Procedure{recursiveConceptMapSearch}{$D.M$,$Q.L$,$Dir$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$Q.L$ has only 1 item}\Comment{Base Case}
                \If{pop($Q.L$) in $D.M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \State{$P\leftarrow$ pop($Q.L$)}                
            \If{$P$ not in $D.M$}
                \State{\textbf{return} $False$}               
            \EndIf
            \State{$D.M^\prime \leftarrow$ Prune all objects $Dir$ of $P$}
            \State{$Dir \leftarrow$ \textbf{changeDirection}($Dir$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M^\prime$,$Q.L$,$Dir$)}
        \EndProcedure
        \State{}
        \Procedure{changeDirection}{$Dir$}
        \If{$Dir$ == 'N'}
            \State{\textbf{return} 'W'}
        \Else
            \State{\textbf{return} 'N'}
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\nrscomment{describe figure }
\begin{figure}[h]
    \centering
        \includesvg[width=0.5\textwidth]{figures/rot-inv-diagram.svg}
    \caption{\textbf{Cardinality-Invariant Object-Object search Method. The query configuration is rotated at most 3$Q$ times, (where $Q$ is the number of query terms) to align each term to the North, West, and Northwest reference points. Pictured above are the original query configuration (left) followed by 2 of the 9 possible rotations for these 3 query terms.}}\label{figure:rot-inv} 
\end{figure}

\begin{algorithm}[h]
    \caption{Cardinality-Invariant Object-Object Search}\label{alg:cardInvSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{cardinalityInvariantObjectObjectSearch}{$Q$, $D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$B \leftarrow$ Bounding box of points in $Q$}
            \State{$C\leftarrow$ centroid of points in $Q$} 
            \State{$N\leftarrow$ North Center point of $B$} 
            \State{$W\leftarrow$ West Center point of $B$} 
            \State{$NW\leftarrow$ Northwest Center point of $B$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \For{Each $Dir$ in [$N, W, NW$]} \Comment{Reference \textbf{Dir}ection}
                \For{Each point $P$ in $Q$}
                    \State{$\theta$ $\leftarrow$ $\angle$ $R$$C$$P$ }\Comment{Measured clockwise}
                    \State{$Q^\prime \leftarrow$ Rotate($Q$, $\theta$)}\Comment{Rotate counterclockwise}
                    \State{$M$ $\leftarrow$ createConceptMap($Q^\prime$)}
                    \State{$Q^\prime.L$ $\leftarrow$ orderSearchTerms($M$)}
                    \If{recursiveObjectObjectSearch($D.M$, $Q^\prime.L$) == True}
                        \State{\textbf{return} True}               
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} False}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Cardinality-Invariant Object-Object Search}
\textbf{Cardinality Invariance} extends object-object search (algorithm~\ref{alg:gridSearch}) by removing the assumption that the user knows where north is. 
We address the lack of known global direction by rotating the query terms a minimal number of times to cover the distinct configurations. 
Algortihm~\ref{alg:cardInvSearch} describes the process of rotating the points of the query term around their centroid, and a visual depiction is in figure~\ref{figure:rot-inv}.
To do this, we generate the minimum bounding rectangle for the query points, and place three additional query points: 'west', 'north' and 'northwest' on the bounding rectangle relative to the centroid. 
We use each of these reference points as part of a triangle with verticies of the reference point, the centroid and the point to be rotated. 
We use the cosine rule to calculate the minimal angle of rotation to have any point cross any of the 'lines' connecting the centroid to the reference points while rotating clockwise. 
When one of those lines is crossed, the state is saved as a possible unique spatial configuration of points, and repeated until they return to their original position. 
We take the unique set of all possible rotations and use that unique set to query each of the locations, allowing the user to query in a more realistic manner with only a modest impact on complexity at realistic query sizes. 

\subsection{Data Generation}
\par{Meaningful experimentation to support our theoretical complexity analysis requires data that is controlled enough to allow for evaluating precision and recall, but closely mimics the randomness of real-world spatial data.
The spatial randomnedd we see in locations, and the objects within them are not uniformly distributed, and generating synthetic data requires an approach that is able to reflect the power law distributions observed in location and object clusters.  
We developed a data generator to support the evaluation of our algorithms. 
The data generator use an implementations of the Recursive Matrix (RMAT) graph generation algorithm \cite{Chakrabarti2004} to produce the adjacency matrix of a scale-free graph with tunable size and density (setting the distribution parameters to reflect those standardized in graph500.).
We use the edges of that adjacency matrix to represent the 'coordinates' of the points we are inserting into a location. 
Labelling the points with their 'names' (object classes) involves generating samples across an inverse Pareto distribution, seperating those samples into \textit{n} bins and then walking through that sample, assigning each bin encountered in turn to an unlabelled point.
To ensure we can control the query evaluation, we insert queries from a disjoint set of labels into the location once the initial labelling has been completed. 
To reflect real-world variance, those input queries can be shifted vertically, shifted horizontally, starburst and rotated, or any combination of those four.
The generator allows a user to generate an experiment, controlling how many locations there are, how many queries there are, how many objects are in each, and the amount of distortion applied to those queries to simulate the power-law distributions of locations, objects and object classes observed in the real world.}