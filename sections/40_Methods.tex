\section{Methods}
\label{section:methods}

\begin{algorithm}[H]
    \caption{Location-Object Search}\label{alg:locSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{Q.Loc} Midpoint of query canvas, representing position of Location sought}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{objectLocationSearch}{$Q$, $D$, $Q.Loc$, $D.Loc$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$D.Dict \leftarrow$ makeLocationCentricStructure($D$,$D.Loc$)}
            \State{$Q.Dict \leftarrow$ makeLocationCentricStructure($Q$,$Q.Loc$)}
            \State{$matches \leftarrow$ 0}
            \For{Each $quadrant$ in [$NW$, $NE$, $SW$, $SE$]}
                \For{Each point $P$ in $Q.Dict[quadrant]$}
                    \If{$D.Dict[quadrant]$ contains $P$}
                        \State{$matches \leftarrow matches$ + 1} 
                        \State{Pop $P$ from $D.Dict[quadrant]$} %\Comment So multiples of same objects in query are counted
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} $matches$} \Comment Used to rank against other candidate locs
        \EndProcedure
        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{MakeLocationCentricStructure}{$D$, $D.Loc$}
            \State{$Dict \leftarrow $\{ $NW$: [ ], $NE$:[ ], $SW$: [ ], $SE$: [ ] \}}
            \For{$Obj$ in $D$}%\Comment{R is a row describing a single object}
                \If{$Obj.y$ < $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{}
                        \State{Add $Obj.Name$ to $Dict.SW$}
                \ElsIf{$Obj.y$ < $D.Loc.y$ and $Obj.x$ >= $D.Loc.x$}
                        \State{Add $Obj.Name$ to $Dict.SE$}
                    %\EndIf
                \ElsIf{$Obj.y$ >= $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{$R.x$ <= $Loc.x$} 
                        \State{Add $Obj.Name$ to $Dict.NW$}
                \Else
                        \State{Add $Obj.Name$ to $Dict.NE$}
                    %\EndIf
                \EndIf 
            \EndFor
            \State{\textbf{return} $Dict$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\nrscomment{this needs to be written based on how it's implemented.}

\nrscomment{Generalize makeLocationCentricStructure to use it for query and data, then do set intersections to get num matches?}

\nrscomment{Return ranked set of locations as output}


\subsection{Object-Location Search}
\textbf{Object-location} relations are encoded as a per-location index that subdivides the search space into four quadrants - NorthWest, NorthEast, SouthWest, and SouthEast, splitting on the location coordinates. The division of space aims to emulate how people relate the world to their position in it geospatially. 
\nrscomment{describe more here}
Searching the object-location structure involves a simple iteration through the candidate locations, searching each one's NW/NE/SW/SE quadrants for the relevant query objects, and ranking the locations based on how many objects were found in the correct quadrant.







\begin{algorithm}[h]
    \caption{Concept Mapping}\label{alg:geoToGrid}
    \begin{algorithmic}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{createConceptMap}{$D$}
            \State{xList, yList $\leftarrow$ []} 
            %\State{LatList = []} \Comment{A list}
            \State{$M$ $\leftarrow$ [[][]]} \Comment{A matrix of 0s}
            %\State{Sort rows from North to South}
            \For{$Obj$ in $D$} \Comment{Where $D$ sorted (desc) on y coord}     
                \State{Add $Obj$ to $yList$} %\Comment{$R.ID$ is the obj unique ID}
            \EndFor
            %\State{Sort rows from West to East}         
            \For{$Obj$ in $D$}  \Comment{Where $D$ sorted (desc) on x coord}  
                \State{Add $Obj$ to $xList$}
            \EndFor          
            \For{$Obj$ in $xlist$}          
                \State{$i \leftarrow$ index of $Obj$ in $xList$}
                \State{$j \leftarrow$ index of $Obj$ in $yList$}               
                \State{$M$[$i$][$j$] $\leftarrow$ $Obj.Name$} %\Comment{Name of object with $ID$}
            \EndFor        
            \State{\textbf{return} $xList$, $yList$}
        \EndProcedure

        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{xList} A list of terms sorted by x-coordinate}}\Comment{Same number of terms as $yList$}
        \State{\textit{\textbf{yList} A list of terms sorted by y-coordinate}}\Comment{Same number of terms as $xList$}
        \State{- - - - -}
        \Procedure{Order Search Terms}{$xList$, $yList$}
            \State{$Traversed$ $\leftarrow$ []}
            \State{$dir$ = 'x'}
            \While{len($Traversed$) < len($xList$)} 
                \If{$xList$ not empty and $dir$ == 'x'}
                    \State{$term$ = pop($xList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'y'}
                    \EndIf
                \EndIf
                \If{$yList$ not empty and $dir$ == 'y'}
                    \State{$term$ = pop($yList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'x'}
                    \EndIf
                \EndIf
            \EndWhile
            \State{\textbf{return} $Traversed$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Object-Object Search}
\textbf{Object-object} relations encode objects in sparse $NxN$ matrices, where $N$ is the number of objects at a location. 
Using algorithm \ref{alg:geoToGrid}, we assign each object in a given location to a position $(i,j)$ in the matrix where $i$ is its order of appearance from north to south and $j$ is the same object's order of appearance from west to east (depicted in Figure \ref{fig:CM-OO-Setup}). \nrscomment{clean up this subsection/ describe more}

Searching the object-object concept maps involves using the recursive grid search (Algorithm \ref{alg:gridSearch}) to identify which locations have objects matching the configuration specified in the pictorial query, and returning the relevant set of results. 
The pictorial query is first converted into a concept map matrix using the process outlined in \nrscomment{...} and the search terms in the matrix are ordered into a queue with the northernmost enqueued first, followed by the westernmost, then the second northernmost, and so on until all search terms are in the queue.
Then, the grid search is employed to recursively prune the search space and quickly eliminate candidate locations that do not match the query configuration.
This process is depicted visually in Figure \ref{figure:ConceptMap}.




\begin{algorithm}[h!]
    \caption{Object-Object Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{objectObjectSearch}{$Q$, $D$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \State{$Q.M$ $\leftarrow$ createConceptMap($Q$)}
            \State{$Q.L$ $\leftarrow$ orderSearchTerms($M$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M$,$Q.L$)}
        \EndProcedure
        
        \State{--------------------------------------------------------------------------------------------------------} 
        \State{\textit{\textbf{D.M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{Q.L} A NW to SE ordered list of query objects}}
        \State{\textit{\textbf{Dir} The alternating cardinal direction to prune from, 'N' (default) or 'W'}}
        \State{- - - - -}
        \Procedure{recursiveConceptMapSearch}{$D.M$,$Q.L$,$Dir$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$Q.L$ has only 1 item}\Comment{Base Case}
                \If{pop($Q.L$) in $D.M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \State{$P\leftarrow$ pop($Q.L$)}                
            \If{$P$ not in $D.M$}
                \State{\textbf{return} $False$}               
            \EndIf
            \State{$D.M^\prime \leftarrow$ Prune all objects $Dir$ of $P$}
            \State{$Dir \leftarrow$ \textbf{changeDirection}($Dir$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M^\prime$,$Q.L$,$Dir$)}
        \EndProcedure
        \State{}
        \Procedure{changeDirection}{$Dir$}
        \If{$Dir$ == 'N'}
            \State{\textbf{return} 'W'}
        \Else
            \State{\textbf{return} 'N'}
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\nrscomment{describe figure }
\begin{figure}[h]
    \centering
        \includesvg[width=0.5\textwidth]{figures/rot-inv-diagram.svg}
    \caption{\textbf{Cardinality-Invariant Object-Object search Method. The query configuration is rotated at most 3$Q$ times, (where $Q$ is the number of query terms) to align each term to the North, West, and Northwest reference points. Pictured above are the original query configuration (left) followed by 2 of the 9 possible rotations for these 3 query terms.}}\label{figure:rot-inv} 
\end{figure}

\begin{algorithm}[h]
    \caption{Cardinality-Invariant Object-Object Search}\label{alg:cardInvSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{cardinalityInvariantObjectObjectSearch}{$Q$, $D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$B \leftarrow$ Bounding box of points in $Q$}
            \State{$C\leftarrow$ centroid of points in $Q$} 
            \State{$N\leftarrow$ North Center point of $B$} 
            \State{$W\leftarrow$ West Center point of $B$} 
            \State{$NW\leftarrow$ Northwest Center point of $B$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \For{Each $Dir$ in [$N, W, NW$]} \Comment{Reference \textbf{Dir}ection}
                \For{Each point $P$ in $Q$}
                    \State{$\theta$ $\leftarrow$ $\angle$ $R$$C$$P$ }\Comment{Measured clockwise}
                    \State{$Q^\prime \leftarrow$ Rotate($Q$, $\theta$)}\Comment{Rotate counterclockwise}
                    \State{$M$ $\leftarrow$ createConceptMap($Q^\prime$)}
                    \State{$Q^\prime.L$ $\leftarrow$ orderSearchTerms($M$)}
                    \If{recursiveObjectObjectSearch($D.M$, $Q^\prime.L$) == True}
                        \State{\textbf{return} True}               
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} False}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

