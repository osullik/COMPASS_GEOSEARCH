\section{COMPASS Search Algorithms}
\label{section:methods}
Our choice of data structures allow us the freedom to employ search methods not well suited for graph structures. 
We show how the abstraction to encoding only relative position information makes the problem more tractable. 
In this section we outline the methods used to accomplish \emph{COMPASS}'s three forms of spatial search, and the process used to generate data for our experimental setup to test those search methods.

\begin{algorithm}[h!]
    \caption{Location-Object Search}\label{alg:locSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{Q.Loc} Midpoint of query canvas, representing position of Location sought}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{objectLocationSearch}{$Q$, $D$, $Q.Loc$, $D.Loc$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$D.Dict \leftarrow$ makeLocationCentricStructure($D$,$D.Loc$)}
            \State{$Q.Dict \leftarrow$ makeLocationCentricStructure($Q$,$Q.Loc$)}
            \State{$matches \leftarrow$ 0}
            \For{Each $quadrant$ in [$NW$, $NE$, $SW$, $SE$]}
                \For{Each point $P$ in $Q.Dict[quadrant]$}
                    \If{$D.Dict[quadrant]$ contains $P$}
                        \State{$matches \leftarrow matches$ + 1} 
                        \State{Pop $P$ from $D.Dict[quadrant]$} %\Comment So multiples of same objects in query are counted
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} $matches$} \Comment Used to rank against other candidate locs
        \EndProcedure
        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{MakeLocationCentricStructure}{$D$, $D.Loc$}
            \State{$Dict \leftarrow $\{ $NW$: [ ], $NE$:[ ], $SW$: [ ], $SE$: [ ] \}}
            \For{$Obj$ in $D$}%\Comment{R is a row describing a single object}
                \If{$Obj.y$ < $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{}
                        \State{Add $Obj.Name$ to $Dict.SW$}
                \ElsIf{$Obj.y$ < $D.Loc.y$ and $Obj.x$ >= $D.Loc.x$}
                        \State{Add $Obj.Name$ to $Dict.SE$}
                    %\EndIf
                \ElsIf{$Obj.y$ >= $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{$R.x$ <= $Loc.x$} 
                        \State{Add $Obj.Name$ to $Dict.NW$}
                \Else
                        \State{Add $Obj.Name$ to $Dict.NE$}
                    %\EndIf
                \EndIf 
            \EndFor
            \State{\textbf{return} $Dict$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Location-Object Search Method}
\par{
    The Location-Object search assumes a globally aligned coordinate system and the existence of a Location-Object data structure for each location in the region of interest.
    To issue a Location-Object query, a user inserts query objects around the `center' of the location on the query canvas, encoding them by their directional constraints with respect to the location (NW/NE/SW/SE). 
    The search is executed on the Location-Object structure by iterating through the candidate locations, searching each location's NW/NE/SW/SE quadrants for object-quadrant relationships that match the directional constraints specified in the query.
    Figure \ref{fig:CM-LO-Query} shows how to query the Location-Object data structure, and the process is formalized by Algorithm~\ref{alg:locSearch}.
}
\par{
    The search function returns candidate locations ranked by the number of query terms that match the appropriate quadrant with respect to the location. 
    Multiple constraints can be combined to form a more specific query, such as a lake northwest of the location and a pond southeast of the location.
    Partial matches are returned, ranked by how many of the query's directional constraints are satisfied.
    }

 
%A true positive match occurs when the number of discovered objects in a location matches the number of query objects.
%For example, if the user queries for two objects in the southwest and one in the northeast, true positive matches will be all locations that feature those three objects in that configuration. 



\begin{algorithm}[h]
    \caption{Concept Mapping}\label{alg:geoToGrid}
    \begin{algorithmic}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{createConceptMap}{$D$}
            \State{xList, yList $\leftarrow$ []} 
            %\State{LatList = []} \Comment{A list}
            \State{$M$ $\leftarrow$ [[][]]} \Comment{A matrix of 0s}
            %\State{Sort rows from North to South}
            \For{$Obj$ in $D$} \Comment{Where $D$ sorted (desc) on y coord}     
                \State{Add $Obj$ to $yList$} %\Comment{$R.ID$ is the obj unique ID}
            \EndFor
            %\State{Sort rows from West to East}         
            \For{$Obj$ in $D$}  \Comment{Where $D$ sorted (desc) on x coord}  
                \State{Add $Obj$ to $xList$}
            \EndFor          
            \For{$Obj$ in $xlist$}          
                \State{$i \leftarrow$ index of $Obj$ in $xList$}
                \State{$j \leftarrow$ index of $Obj$ in $yList$}               
                \State{$M$[$i$][$j$] $\leftarrow$ $Obj.Name$} %\Comment{Name of object with $ID$}
            \EndFor        
            \State{\textbf{return} $xList$, $yList$}
        \EndProcedure

        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{xList} A list of terms sorted by x-coordinate}}\Comment{Same number of terms as $yList$}
        \State{\textit{\textbf{yList} A list of terms sorted by y-coordinate}}\Comment{Same number of terms as $xList$}
        \State{- - - - -}
        \Procedure{Order Search Terms}{$xList$, $yList$}
            \State{$Traversed$ $\leftarrow$ []}
            \State{$dir$ = 'x'}
            \While{len($Traversed$) < len($xList$)} 
                \If{$xList$ not empty and $dir$ == 'x'}
                    \State{$term$ = pop($xList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'y'}
                    \EndIf
                \EndIf
                \If{$yList$ not empty and $dir$ == 'y'}
                    \State{$term$ = pop($yList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'x'}
                    \EndIf
                \EndIf
            \EndWhile
            \State{\textbf{return} $Traversed$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Object-Object Search Method}

Object-Object search allows a user to retrieve locations by specifying directional constraints between objects and comparing them to the directional relationships of objects in the underlying database. 
It assumes the user query complies with the globally aligned coordinate system.

%First, any database object that is more north (west) than the northernmost (westernmost) database object matching the northernmost (westermost) query object cannot be part of a match. \nrscomment{this sentence needs to be made more digestible}
The Object-Object query is specified pictorially, and is converted into a concept map matrix to capture its directional constraints.
The \textit{Recursive Grid Search} (Algorithm~\ref{alg:gridSearch}) uses the input concept map query to identify which locations have objects matching the directional constraints specified in the query. 
The query process is depicted in Figure \ref{fig:CM-OO-Query}, but in general terms, the \textit{Recursive Grid Search} traverses the database objects starting from the north.
Once the northernmost query object is encountered, any database objects previously encountered are irrelevant to the query and can be pruned.
The same holds for the western direction.
Pruning occurs recursively in alternating directions until all query objects are found, or the traversal completes without matching all query terms.

%To generate the query input, the pictorial query is first converted into a concept map matrix to capture its directional constraints.
%Next, the search terms in the query matrix are ordered into a queue with the northernmost enqueued first, followed by the westernmost, then the second northernmost, and so on.
%Finally, the grid search is employed to recursively prune the search space and quickly eliminate candidate locations that do not match the query configuration, 



% For example, a tree, a pond, and a sign might form a triangle, with each object having a directional constraint to every other object in the query (i.e., tree upper left of pond, pond lower right of sign, and sign lower left of tree).
% As the number of objects of interest increases, the number of pairwise directional constraints needed to specify the query snowballs.


\begin{algorithm}[h!]
    \caption{Object-Object Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{objectObjectSearch}{$Q$, $D$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \State{$Q.M$ $\leftarrow$ createConceptMap($Q$)}
            \State{$Q.L$ $\leftarrow$ orderSearchTerms($M$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M$,$Q.L$)}
        \EndProcedure
        
        \State{--------------------------------------------------------------------------------------------------------} 
        \State{\textit{\textbf{D.M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{Q.L} A NW to SE ordered list of query objects}}
        \State{\textit{\textbf{Dir} The alternating cardinal direction to prune from, 'N' (default) or 'W'}}
        \State{- - - - -}
        \Procedure{recursiveConceptMapSearch}{$D.M$,$Q.L$,$Dir$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$Q.L$ has only 1 item}\Comment{Base Case}
                \If{pop($Q.L$) in $D.M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \State{$P\leftarrow$ pop($Q.L$)}                
            \If{$P$ not in $D.M$}
                \State{\textbf{return} $False$}               
            \EndIf
            \State{$D.M^\prime \leftarrow$ Prune all objects $Dir$ of $P$}
            \State{$Dir \leftarrow$ \textbf{changeDirection}($Dir$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M^\prime$,$Q.L$,$Dir$)}
        \EndProcedure
        \State{}
        \Procedure{changeDirection}{$Dir$}
        \If{$Dir$ == 'N'}
            \State{\textbf{return} 'W'}
        \Else
            \State{\textbf{return} 'N'}
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{figure}[h]
    \centering
        \includesvg[width=0.5\textwidth]{figures/rot-inv-diagram.svg}
    \caption{\textbf{Cardinality-Invariant Object-Object search Method. The query configuration is rotated at most 3$Q$ times, (where $Q$ is the number of query terms) to align each term to the North, West, and Northwest reference points. Pictured above are the original query configuration (left) followed by two of the nine possible rotations for these three query terms.}}\label{figure:rot-inv} 
\end{figure}

\begin{algorithm}[h]
    \caption{Cardinality-Invariant Object-Object Search}\label{alg:cardInvSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{cardinalityInvariantObjectObjectSearch}{$Q$, $D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$B \leftarrow$ Bounding box of points in $Q$}
            \State{$C\leftarrow$ centroid of points in $Q$} 
            \State{$N\leftarrow$ North Center point of $B$} 
            \State{$W\leftarrow$ West Center point of $B$} 
            \State{$NW\leftarrow$ Northwest Center point of $B$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \For{Each $Dir$ in [$N, W, NW$]} \Comment{Reference \textbf{Dir}ection}
                \For{Each point $P$ in $Q$}
                    \State{$\theta$ $\leftarrow$ $\angle$ $R$$C$$P$ }\Comment{Measured clockwise}
                    \State{$Q^\prime \leftarrow$ Rotate($Q$, $\theta$)}\Comment{Rotate counterclockwise}
                    \State{$M$ $\leftarrow$ createConceptMap($Q^\prime$)}
                    \State{$Q^\prime.L$ $\leftarrow$ orderSearchTerms($M$)}
                    \If{recursiveObjectObjectSearch($D.M$, $Q^\prime.L$) == True}
                        \State{\textbf{return} True}               
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} False}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Cardinality-Invariant Object-Object Search Method}
\textbf{Cardinality Invariance} extends object-object search (Algorithm~\ref{alg:gridSearch}) by removing the assumption that the user query complies with the globally aligned coordinate system.
%
We address the lack of certainty in coordinate system alignment by rotating the query pattern the minimal number of times needed to cover the distinct configurations with respect to the actual cardinal directions.
%
Algortihm~\ref{alg:cardInvSearch} describes the process of rotating the points of the query term around their centroid, and a visual depiction is in figure~\ref{figure:rot-inv}.
To do this, we generate the minimum bounding rectangle for the query points, and label three reference points: `North', `West', and `Northwest' on the bounding rectangle relative to the centroid. 
For each point in the query, we then compute the angle between each reference point, the centroid, and the given point. 
Rotating the entire query configuration by each of these angle aligns the given point to each reference direction.
The unique set of query configurations obtained in this manner represent the minimum set of object-object queries that then need to be run to determine if the pattern specified in the query matches, irrespective of cardinality. 