\section{COMPASS Search Algorithms}
\label{section:methods}

In this section we outline the methods used to accomplish \emph{COMPASS}'s 3 forms of spatial search, and describe the process used to generate data for our experimental setup to test those search methods.

\begin{algorithm}[h!]
    \caption{Location-Object Search}\label{alg:locSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{Q.Loc} Midpoint of query canvas, representing position of Location sought}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{objectLocationSearch}{$Q$, $D$, $Q.Loc$, $D.Loc$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$D.Dict \leftarrow$ makeLocationCentricStructure($D$,$D.Loc$)}
            \State{$Q.Dict \leftarrow$ makeLocationCentricStructure($Q$,$Q.Loc$)}
            \State{$matches \leftarrow$ 0}
            \For{Each $quadrant$ in [$NW$, $NE$, $SW$, $SE$]}
                \For{Each point $P$ in $Q.Dict[quadrant]$}
                    \If{$D.Dict[quadrant]$ contains $P$}
                        \State{$matches \leftarrow matches$ + 1} 
                        \State{Pop $P$ from $D.Dict[quadrant]$} %\Comment So multiples of same objects in query are counted
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} $matches$} \Comment Used to rank against other candidate locs
        \EndProcedure
        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{\textit{\textbf{D.Loc} Location to which Objects in D are assigned}}
        \State{- - - - -}
        \Procedure{MakeLocationCentricStructure}{$D$, $D.Loc$}
            \State{$Dict \leftarrow $\{ $NW$: [ ], $NE$:[ ], $SW$: [ ], $SE$: [ ] \}}
            \For{$Obj$ in $D$}%\Comment{R is a row describing a single object}
                \If{$Obj.y$ < $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{}
                        \State{Add $Obj.Name$ to $Dict.SW$}
                \ElsIf{$Obj.y$ < $D.Loc.y$ and $Obj.x$ >= $D.Loc.x$}
                        \State{Add $Obj.Name$ to $Dict.SE$}
                    %\EndIf
                \ElsIf{$Obj.y$ >= $D.Loc.y$ and $Obj.x$ < $D.Loc.x$}
                    %\If{$R.x$ <= $Loc.x$} 
                        \State{Add $Obj.Name$ to $Dict.NW$}
                \Else
                        \State{Add $Obj.Name$ to $Dict.NE$}
                    %\EndIf
                \EndIf 
            \EndFor
            \State{\textbf{return} $Dict$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsection{Object-Location Search Method}
\textbf{Object-location} relations are encoded as a per-location index that subdivides the search space into four quadrants - NorthWest, NorthEast, SouthWest, and SouthEast, splitting on the location coordinates.
It assumes that the user sees the 'center' of the location as their reference point, and assumes that they know where North is when querying. 
To conduct a query, a user inserts query terms around the 'center' of a location on the query canvas. 
Algorithm~\ref{alg:locSearch} describes searching the object-location structure with a simple iteration through the candidate locations, searching each one's NW/NE/SW/SE quadrants for the relevant query objects.
A true positive match occurs when the number of discovered objects in a location matches the number of query objects.
For example, if the user queries for two objects in the southwest and one in the northeast, true positive matches will be all locations that feature those three objects in that configuration. 
There is also the ability to return partial matches, ranked by how close they are to an exact match.


\begin{algorithm}[h]
    \caption{Concept Mapping}\label{alg:geoToGrid}
    \begin{algorithmic}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{createConceptMap}{$D$}
            \State{xList, yList $\leftarrow$ []} 
            %\State{LatList = []} \Comment{A list}
            \State{$M$ $\leftarrow$ [[][]]} \Comment{A matrix of 0s}
            %\State{Sort rows from North to South}
            \For{$Obj$ in $D$} \Comment{Where $D$ sorted (desc) on y coord}     
                \State{Add $Obj$ to $yList$} %\Comment{$R.ID$ is the obj unique ID}
            \EndFor
            %\State{Sort rows from West to East}         
            \For{$Obj$ in $D$}  \Comment{Where $D$ sorted (desc) on x coord}  
                \State{Add $Obj$ to $xList$}
            \EndFor          
            \For{$Obj$ in $xlist$}          
                \State{$i \leftarrow$ index of $Obj$ in $xList$}
                \State{$j \leftarrow$ index of $Obj$ in $yList$}               
                \State{$M$[$i$][$j$] $\leftarrow$ $Obj.Name$} %\Comment{Name of object with $ID$}
            \EndFor        
            \State{\textbf{return} $xList$, $yList$}
        \EndProcedure

        \State{--------------------------------------------------------------------------------------------------------}
        \State{\textit{\textbf{xList} A list of terms sorted by x-coordinate}}\Comment{Same number of terms as $yList$}
        \State{\textit{\textbf{yList} A list of terms sorted by y-coordinate}}\Comment{Same number of terms as $xList$}
        \State{- - - - -}
        \Procedure{Order Search Terms}{$xList$, $yList$}
            \State{$Traversed$ $\leftarrow$ []}
            \State{$dir$ = 'x'}
            \While{len($Traversed$) < len($xList$)} 
                \If{$xList$ not empty and $dir$ == 'x'}
                    \State{$term$ = pop($xList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'y'}
                    \EndIf
                \EndIf
                \If{$yList$ not empty and $dir$ == 'y'}
                    \State{$term$ = pop($yList$)}
                    \If{$term$ not in $Traversed$}
                        \State{Append $term$ to $Traversed$}
                        \State{$dir$ = 'x'}
                    \EndIf
                \EndIf
            \EndWhile
            \State{\textbf{return} $Traversed$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Object-Object Search Method}
\textbf{Object-object} search allows a user to search locations for spatial configurations of objects. 
It assumes that the user knows the cardinal bearings of their object configuration, but not where those objects are with respect to the location they belong to.
Queries are specified pictorially.
Both the locations and the queries are encoded as objects in $NxN$ matrices, where $N$ is the number of objects associated with a location or query. 
Using Algorithm~\ref{alg:geoToGrid}, we assign each object in a given location to a position $(i,j)$ in the matrix where $i$ is its order of appearance from north to south and $j$ is the same object's order of appearance from west to east.
The matrix, which we refer to as a \textit{concept map} abstracts away the complexity of tracking distance and the position of each object to all other objects, while preserving the relative spatial positions of objects. 
The intuition of the search is derived from two very simple ideas. First, at any point in time, any point in the location more north than the northern most point or west than the western most point of the query can't be part of a match.
Second, the first idea is recursive.
Searching uses the recursive grid search (Algorithm~\ref{alg:gridSearch}) to identify which locations have objects matching the configuration specified in the pictorial query, and returning the relevant set of results. 
The pictorial query is first converted into a concept map matrix using the process outlined in figure~\ref{figure:ConceptMap}.
Next, the search terms in the query matrix are ordered into a queue with the northernmost enqueued first, followed by the westernmost, then the second northernmost, and so on.
Finally, the grid search is employed to recursively prune the search space and quickly eliminate candidate locations that do not match the query configuration.

\begin{algorithm}[h!]
    \caption{Object-Object Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{objectObjectSearch}{$Q$, $D$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \State{$Q.M$ $\leftarrow$ createConceptMap($Q$)}
            \State{$Q.L$ $\leftarrow$ orderSearchTerms($M$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M$,$Q.L$)}
        \EndProcedure
        
        \State{--------------------------------------------------------------------------------------------------------} 
        \State{\textit{\textbf{D.M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{Q.L} A NW to SE ordered list of query objects}}
        \State{\textit{\textbf{Dir} The alternating cardinal direction to prune from, 'N' (default) or 'W'}}
        \State{- - - - -}
        \Procedure{recursiveConceptMapSearch}{$D.M$,$Q.L$,$Dir$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$Q.L$ has only 1 item}\Comment{Base Case}
                \If{pop($Q.L$) in $D.M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \State{$P\leftarrow$ pop($Q.L$)}                
            \If{$P$ not in $D.M$}
                \State{\textbf{return} $False$}               
            \EndIf
            \State{$D.M^\prime \leftarrow$ Prune all objects $Dir$ of $P$}
            \State{$Dir \leftarrow$ \textbf{changeDirection}($Dir$)}
            \State{\textbf{return recursiveConceptMapSearch}($D.M^\prime$,$Q.L$,$Dir$)}
        \EndProcedure
        \State{}
        \Procedure{changeDirection}{$Dir$}
        \If{$Dir$ == 'N'}
            \State{\textbf{return} 'W'}
        \Else
            \State{\textbf{return} 'N'}
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{figure}[h]
    \centering
        \includesvg[width=0.5\textwidth]{figures/rot-inv-diagram.svg}
    \caption{\textbf{Cardinality-Invariant Object-Object search Method. The query configuration is rotated at most 3$Q$ times, (where $Q$ is the number of query terms) to align each term to the North, West, and Northwest reference points. Pictured above are the original query configuration (left) followed by 2 of the 9 possible rotations for these 3 query terms.}}\label{figure:rot-inv} 
\end{figure}

\begin{algorithm}[h]
    \caption{Cardinality-Invariant Object-Object Search}\label{alg:cardInvSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A query of Objects with names and coordinates}}
        \State{\textit{\textbf{D} A database of Objects with names and coordinates}}
        \State{- - - - -}
        \Procedure{cardinalityInvariantObjectObjectSearch}{$Q$, $D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$B \leftarrow$ Bounding box of points in $Q$}
            \State{$C\leftarrow$ centroid of points in $Q$} 
            \State{$N\leftarrow$ North Center point of $B$} 
            \State{$W\leftarrow$ West Center point of $B$} 
            \State{$NW\leftarrow$ Northwest Center point of $B$} 
            \State{$D.M$ $\leftarrow$ createConceptMap($D$)}
            \For{Each $Dir$ in [$N, W, NW$]} \Comment{Reference \textbf{Dir}ection}
                \For{Each point $P$ in $Q$}
                    \State{$\theta$ $\leftarrow$ $\angle$ $R$$C$$P$ }\Comment{Measured clockwise}
                    \State{$Q^\prime \leftarrow$ Rotate($Q$, $\theta$)}\Comment{Rotate counterclockwise}
                    \State{$M$ $\leftarrow$ createConceptMap($Q^\prime$)}
                    \State{$Q^\prime.L$ $\leftarrow$ orderSearchTerms($M$)}
                    \If{recursiveObjectObjectSearch($D.M$, $Q^\prime.L$) == True}
                        \State{\textbf{return} True}               
                    \EndIf
                \EndFor
            \EndFor
            \State{\textbf{return} False}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Cardinality-Invariant Object-Object Search Method}
\textbf{Cardinality Invariance} extends object-object search (Algorithm~\ref{alg:gridSearch}) by removing the assumption that the user knows the cardinal bearings of the object pattern they wish to search for. 
We address the lack of certainty of cardinal direction by rotating the query pattern the minimal number of times needed to cover the distinct configurations with respect to the actual cardinal bearings. 
Algortihm~\ref{alg:cardInvSearch} describes the process of rotating the points of the query term around their centroid, and a visual depiction is in Figure~\ref{figure:rot-inv}.
To do this, we generate the minimum bounding rectangle for the query points, and label three reference points: 'North', 'West', and 'Northwest' on the bounding rectangle relative to the centroid. 
For each point in the query, we then compute the angle between each reference point, the centroid, and the given point. 
Rotating the entire query configuration by each of these angle aligns the given point to each reference direction.
The unique set of query configurations obtained in this manner represent the minimum set of object-object queries that then need to be run to determine if the pattern specified in the query matches, irrespective of cardinality. 