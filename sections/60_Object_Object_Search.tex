\section{Object-Object Search}
\label{section:obj_search}


\subsection{Spatial Search}

The most powerful form of search \emph{GESTALT} enables is spatial search, where users can query for locations based on the spatial configuration of objects in relation to each other or to the location itself.
However, as discussed in section \ref{section:concept}, this problem quickly becomes intractable as the number of objects increases.
To combat this effect and still enable users to specify spatial queries, we employ a successive pruning approach, where the search space is scoped down in stages until the resulting search is of reasonable scale to execute directly.

\subsubsection{Pruning the Search Space}
The first round of pruning occurs when the user selects the \emph{region} that they wish to search (a pre-condition to performing last-mile search). 
The second layer of pruning happens when the exact membership search method is applied to the query objects.
The set-membership test prunes out any locations that do not contain the objects of interest, thereby avoiding unnecessary computation associated with determining the spatial configuration of objects that are irrelevant to the query (i.e. that belong to locations that are not candidates).
The third layer of pruning occurs during the search of the concept maps. 
The recursive grid search (Algorithm \ref{alg:geoToGrid}) successively segments the search grid into smaller and smaller sections, eliminating impossible results at each step to reduce the total search space to a tractable size.

\subsubsection{Specifying the Query Pictorially}
%A picture is worth a thousand words, and maps are an inherently visual medium. \emph{GESTALT} recognizes the expressive limitations of words alone for geospatial querying and invites a user to query its database with quick sketch maps. 
Humans naturally conceive of and express geospatial relationships visually.
In keeping with a human-centric approach to spatial search, \emph{GESTALT} employs a pictorial query interface that encodes the relative positioning of objects and locations to enable search over those relations.
Figure \ref{fig:GUI-LO} shows the location-object query interface, where the location being sought is represented at the center of the canvas and a user issues a query by positioning objects around that center point. 
Figure \ref{fig:GUI-OO} demonstrates the object-object query interface, where users define the spatial arrangement of objects they want to query by placing the object names on the canvas space. 
%specification abstracts away the need for the user to describe the relations of objects using the confusing language around cardinal directions, and replaces it with the simple visual task of trying to recreate the pattern being held in your mind's eye.
%We implement a very rudimentary prototype pictorial query interface using Python Tkinter.
%The interface has two modes. 

\subsubsection{Searching the Concept Maps}
To avoid unnecessary computation, the spatial searches are only performed after the initial membership check has been done to narrow the pool of locations to those that contain the right set of objects.
Searching the object-location concept maps involves a simple iteration through the candidate locations, searching each one's NW/NE/SW/SE quadrants for the relevant query objects, and ranking the locations based on how many objects were found in the correct quadrant. 
%requires the user to specify a query, either pictorially or with keywords, for each quadrant of an unknown candidate location, what objects they expect to find there.
%Using that query input, the searcher iterates through each location and inspects its NW/NE/SW/SE subdivisions of space, comparing them to the query. 
%Where the same object occurs in the same quadrant in the query and a candidate location, one point is added to the location's score. 
%When all locations have been checked, the candidate locations (i.e. locations with $> 1$ match) are returned, ranked from most to fewest matches. 
Searching the object-object concept maps involves using the recursive grid search (Algorithm \ref{alg:gridSearch}) to identify which locations have objects matching the configuration specified in the pictorial query, and returning the relevant set of results. 
The pictorial query is first converted into a concept map matrix using the process outlined in Appendix \ref{appendix:conceptcreation} and the search terms in the matrix are ordered into a queue with the northernmost enqueued first, followed by the westernmost, then the second northernmost, and so on until all search terms are in the queue.
Then, the grid search is employed to recursively prune the search space and quickly eliminate candidate locations that do not match the query configuration.
This process is depicted visually in Figure \ref{figure:ConceptMap}.
%NSCH add back in if room allows:
%The broad idea is that while finding all possible instances and configurations of a geospatial pattern rapidly approaches NP-Completeness, we can determine if there is any possible match quite easily by using the query term to prune sections of the concept map that are irrelevant. 
%For example, any objects in the location that are north of the most northerly query term that exists in the object cannot possibly satisfy the query, and so we prune those rows. 
%The same occurs for the western direction, and then recursively north and west until the query is eithers satisfied or rejected. The search occurs for each candidate location and requires less than a single matrix traversal to determine if anywhere in that location the query pattern occurs. 

\begin{algorithm}
    \caption{Recursive Grid Search}\label{alg:gridSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
        \State{\textit{\textbf{D} The alternating direction we prune from, 'north' (default) or 'west'}}
        \State{- - - - -}
        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \If{$L$ has only 1 item}\Comment{Base Case}
                \If{pop($L$) in $M$}
                    \State{\textbf{return} $True$}              
                \Else
                    \State{\textbf{return} $False$}
                \EndIf            
            \EndIf
            \State{$PruningPoint\leftarrow$ pop($L$)}                
            \If{$PruningPoint$ not in $M$}
                \State{\textbf{return} $False$}               
            \EndIf
            \State{$M^\prime \leftarrow$ Prune all objects $D$ of $PruningPoint$}
            \State{\textbf{return recursiveGridSearch}($M^\prime$,$L$,$D.\textbf{changeDirection}()$)}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}




\begin{algorithm}
    \caption{Cardinality-Invariant Object-Object Search}\label{alg:cardInvSearch}
    \begin{algorithmic}
        \State{\textit{\textbf{Q} A pictorial query specified as (x,y) coords in a canvas C}}
        \State{\textit{\textbf{C} Canvas containing query points}}
        \State{- - - - -}
        \Procedure{objectObjectSearch}{$Q$,$C$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
            \State{$Q.x\leftarrow$ centroid of points in $Q$} 
            \State{$N\leftarrow$ North Center point of $C$} 
            \For{Each point $P$ in $Q$}
                \State{$\theta$ $\leftarrow$ $\angle$ $N$$Q.x$$P$ }\Comment{Measured clockwise}
                \State{$Q' \leftarrow$ Rotate($Q$, $\theta$)}\Comment{Rotate counterclockwise}
                \State{$M$ $\leftarrow$ createConceptMap($Q'$)}
                \State{$L$ $\leftarrow$ orderSearchTerms($M$)}
                \If{recursiveGridSearch($M$,$L$) == True}
                    \State{\textbf{return} True}               
                \EndIf
            \EndFor
            \State{\textbf{return} False}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

%\begin{algorithm}
%    \caption{Recursive Grid Search}\label{alg:gridSearch}
%    \begin{algorithmic}
%        \State{\textit{\textbf{M} A ConceptMap Matrix with objects or 0s; [0,0] is NW most point}}
%        \State{\textit{\textbf{L} A NW to SE ordered list of objects to search for}}
%        \State{\textit{\textbf{D} The direction of Pruning, 'northToSouth' or 'westToEast'}}
%        \State{- - - - -}
%        \Procedure{recursiveGridSearch}{$M$,$L$,$D$} %\Comment{$M$ a matrix of a Loc's objects, $L$ an ordered list of objects to search for, $D$ is the pruning direction}
%            \If{$L$ has only 1 item}\Comment{Base Case}
%                \If{pop($L$) in $M$}
%                    \State{\textbf{return} $True$}              
%                \Else
%                    \State{\textbf{return} $False$}
%                \EndIf            
%            \EndIf
%            \If{$D$ is $northToSouth$}
%                \State{$NorthernObject\leftarrow$ pop($L$)}                
%                \If{$NorthernObject$ not in $M$}
%                    \State{\textbf{return} $False$}               
%                \EndIf
%               \State{$M\leftarrow$ Prune all objects north of $NorthernObject$}
%                \State{\textbf{return recursiveGridSearch}($M$,$L$,$westToEast$)}
%            \EndIf
%            \If{$D$ is $eastToWest$}
%                \State{$WesternObject\leftarrow$ pop($L$)}
%                \If{$WesternObject$ not in $M$}
%                    \State{\textbf{return} $False$}
%                \EndIf
%                \State{$M\leftarrow$ Prune all objects west of $WesternObject$}
%                \State{\textbf{return recursiveGridSearch}($M$,$L$,$northToSouth$)}
%            \EndIf
%       \EndProcedure
%    \end{algorithmic}
%\end{algorithm}



%The worst case complexity is for a search of N object terms where every object category is mapped to every location L. In that case we have to do N lookups to pull N sets of size L and intersect them. Realistically this would not happen and some object classes would be very discriminative and we could intersect those first to be more efficient.



%To test the scalability of \emph{GESTALT} we test it over a \textit{region} densely covered with tags for objects and locations - the District of Columbia. 
%Aside from waiting for the download of photos from the flickr API and the use of YOLO on those photos, the construction of the DC dataset occurs within a few seconds. 
%We compare our methods of searching across our inverted index and two concept-map data structures and find that all are performant using the DC dataset, reporting detailed results in Figure \ref{figure:PerformanceExperiments}. 
%We can see that 3 query terms is ideal for a user seeking to prune their search space, and that our geospatial pattern matching using our Object-Object recursive grid search avoids the complexity of the more traditional sub-graph matching approach. 


%This is on the DC dataset
%This multiple-ownership situation is one of the driving requirements for implementing concept mapping to extract additional discriminatory information between locations based on the geospatial layout of objects.
%Spatial queries are the most computationally intensive aspect of the search.
%Object-Centric queries require a concept map that describes all n-ary object-object relations, where Location-Centric queries only need describe the set of binary object-location relations.
%These problems of searching by geographic sets of objects have previously been characterized as graph-matching problems. 
%As a graph-matching problem, the difference between a fully connected graph, and a hub-and-spoke graph is significant, particularly as the number of vertices increases. It quickly becomes intractable. \osullikomment{[CITE HERE]}
%We handle both these types of queries by focusing on pruning the search space down to a reasonable size before checking the spatial relationships between objects.

%The search problem must balance precision and recall while not being computationally intractable. An effective search process will use bloom filters to prune the search space for the more complicated geospatial search. Semantic enrichment should be applied independently at each stage of the search in an attempt to improve the recall of \textit{GESTALT}.

%\subsection{Last-mile Search Problem}
%First is a general idea of the region in which the location occurs. 
%Here region means the area surrounding a location. 
%For example, in searching for a winery, it is assumed that the searcher knows that they are in the swan valley region of Western Australia. 
%A region could be an administrative boundary like a city, suburb, or general geographic area. 
%Either way, we assume that the searcher can prune their search space to the commencement of the \textit{last-mile} search before using \textit{GESTALT}.
%The second assumes that the searcher knows a subset of the objects associated with a location. 
%They may or may not know any of the attributes of those objects (for example, material, color etc).

%\emph{GESTALT} is a last-mile search tool that assumes the user has a general idea of the location (region) that they wish to search. 

%Spatial search incorporates the concept of mapping and becomes a spatial search with a specific method depending on the objects' underlying data structure. 
%The general case is as follows: Given a set of locations with geospatial mappings of their child objects and a subset of those geospatial mappings of child objects which location does that subset match? 
%If using a graph structure, each location's objects become a graph where the objects are nodes and the geospatial relations are edges encoding the spatial relations (e.g. west of, north of). It is a subgraph matching problem, which is, of course, NP-Complete. 
%Alternately, representing each location's objects as a KD-Tree rooted on the centroid of the object cluster would allow for dynamic searching. For example, assuming an initial split on the longitude of objects, we could immediately tell that all objects in the left subtree would be west of that root. 
%For either of these geospatial approaches, a translation layer from the positional relational to cardinal relational will need to occur.

%Automating the labeling process is essential to scaling \textit{GESTALT} beyond a trivial size. 
%Options for automation are explored in detail in sections \ref{section:architecture} and \ref{section:related}, but essentially rely on combining remote sensing imagery, ground-based imagery and image metadata to generate mappings of objects to coordinates and parent locations.
%The ability to autonomously determine object locations will set the conditions for the remaining elements of GESTALT to scale.

%The search function has been implemented using the Python \textit{Pandas}\footnote{https://pypi.org/project/pandas/}{Pandas PyPI Repo} library. 
%This approach assumes a single data frame of objects and their determined locations because of the number of possible attributes an object can have and the relatively few that they possess, this is a sparse data structure. 
%The sparseness does indicate the discriminatory power of remembering attributes. For example, a 'door' is not informative, but a 'blue door' on your favorite seaside restaurant is more likely to prune the search space. 
%Because \textit{GESTALT} is designed only for the last-mile search and assumes a small starting region, it may remain feasible to use a simple data structure like a Pandas data frame containing all the objects for all the locations for the query region. 
%More work with the aggregation functions is required to determine if it can support all the necessary aggregation queries comparing object collections. 

%Semantic search has not been implemented. However, the Levenshtein string distance metric (with $threshold = 0.8$) checks for small spelling discrepancies in input words. The priority weights towards retrieving all possible objects, so we accept the increased risk of mistakenly including an object to move the recall closer to 100\%. The next component to be implemented is a nearest-neighbor retrieval mechanism using word embeddings. Prior work indicates that developing databases of embeddings is trivial\cite{Mueller2012}, but using existing datasets tools like word2vec, GloVe and fasttext can generate embeddings over large, publicly available corpora that can be recreated. 

%As discussed in the subsection on Ownership Assignment implementation, bloom filters are a much more efficient operator for set membership testing. 
%The KD-Tree is more suited for geospatial queries, so the Pandas Dataframe currently supports the gaps between the two in supporting aggregation queries. More work is required to integrate these data structures into a coherent search pipeline that maximizes recall while actively pruning the search space at every step so that the searcher can find their locations of interest. Natural language querying is an active area of research yet to present a solution capable of effectively translating natural language queries and their SQL solutions. Given the relatively constrained domain of this problem set, it is a good candidate for implementation as a low priority for improvement. 